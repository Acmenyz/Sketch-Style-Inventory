#import 'alessndro_library.js'

var app = [NSApplication sharedApplication];

var rgbColors = [];
var hexColors = [];

for (var i = 0; i < doc.pages().count(); i++) {

  var page = doc.pages().objectAtIndex(i);

  for (var j = 0; j < page.artboards().count(); j++)Â {

    var artboard = page.artboards().objectAtIndex(j);

    for (var k = 0; k < artboard.layers().count(); k++) {

      var layer = artboard.layers().objectAtIndex(k);
      parse(layer, 0);

    }
  }
}
function parse(layer, level) {
  if (layer.class() == MSLayerGroup) {
    for (var i = 0; i < layer.layers().count(); i++) {
      parse(layer.layers().objectAtIndex(i), level + 1);
    }
  } else if (layer.class() == MSShapeGroup){
    var color = getColorOf(layer);

    if (color != undefined) {
      // need to compare hex values for comparison in include function
      var hex_color = "#" + [color hexValue];

      if(include(hexColors, hex_color) == 0) {
        hexColors.push(hex_color);
        rgbColors.push(color);
      }
    }
  }
}

if (rgbColors.length > 0) alessndro.colour.drawColourPalette(selection[0], rgbColors)

  function include(arr, obj) {
    // indexOf compares searchElement to elements of the Array using strict equality 
    // (the same method used by the ===, or triple-equals, operator).
    return (arr.indexOf(obj) != -1);
  }

  function getColorOf(layer) {
    var color = null;
    switch ([layer class]) {
      case MSTextLayer:
      color = layer.textColor();

      // Check if text layer has a fill color

      var fill = layer.style().fills().firstObject();
      if (fill != undefined && fill.isEnabled()) color = fill.color();
      break;
      default:
      var fill = layer.style().fills().firstObject();
      if (fill != undefined && fill.isEnabled()) color = fill.color();
      break;
    }
    return color;
  }

  function addLayer(name, type, parent) {
    var parent = parent ? parent : current,
    layer = [parent addLayerOfType: type];
    if (name)[layer setName: name];
    return layer;
  }

  function addGroup(name, parent) {
    return addLayer(name, 'group', parent);
  }

  function addShape(name, parent) {
    return addLayer(name, 'rectangle', parent);
  }

  function addText(name, parent) {
    return addLayer(name, 'text', parent);
  }

  function removeLayer(layer) {
    var parent = [layer parentGroup];
    if (parent)[parent removeLayer: layer];
  }

  function setColor(layer, hex, alpha) {
    var color = [[MSColor alloc] init],
    rgb = hexToRgb(hex),
    red = rgb.r / 255,
    green = rgb.g / 255,
    blue = rgb.b / 255,
    alpha = (alpha && !isNaN(alpha) && (alpha <= 1 || alpha >= 0))? alpha: 1;

    [color setRed: red];
    [color setGreen: green];
    [color setBlue: blue];
    [color setAlpha: alpha];

    if( isText(layer) ) {
      [layer setTextColor: color];
    }
    else if( isShape(layer) ) {
      var fills = [[layer style] fills];
      if([fills count] <= 0) [fills addNewStylePart];
      [[[layer style] fill] setColor: color];
    }
  }


  function setSize(layer, width, height, absolute) {
    if(absolute){
      [[layer absoluteRect] setWidth: width];
      [[layer absoluteRect] setHeight: height];
    }
    else{
      [[layer frame] setWidth: width];
      [[layer frame] setHeight: height];
    }

    return layer;
  }


  function setPosition(layer, x, y, absolute) {
    if(absolute){
      [[layer absoluteRect] setX: x];
      [[layer absoluteRect] setY: y];
    }
    else{
      [[layer frame] setX: x];
      [[layer frame] setY: y];
    }

    return layer;
  }

  function getFrame(layer) {
    var frame = [layer frame];

    return {
      x: Math.round([frame x]),
      y: Math.round([frame y]),
      width: Math.round([frame width]),
      height: Math.round([frame height])
    };
  }

  function getRect(layer) {
    var rect = [layer absoluteRect];
    return {
      x: Math.round([rect x]),
      y: Math.round([rect y]),
      width: Math.round([rect width]),
      height: Math.round([rect height])
    };
  }

