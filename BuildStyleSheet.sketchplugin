// init (cmd control alt t)

#import 'Style Inventory/inventory.js'
#import 'sandbox.js'

var definedTextStyles = [];
var definedTextStylesNames = [];
var uniqueTextStyles = [];


function analyseLayerTextStyles ()Â {
	var styles = [[[doc documentData] layerTextStyles] objects]

	for (var i = 0; i < styles.count(); i++) {
		var style = styles.objectAtIndex(i);
		var textStyle = style.style().textStyle().attributes();
		if (!isIncluded(definedTextStyles, textStyle)) {
	    	definedTextStyles.push(textStyle);
	    	definedTextStylesNames.push(style.name())
	    }
	}
	// sort by font size
	definedTextStyles.sort(compare);
}

function analyseTextStyles() {

	// Loop through pages

	for (var i = 0; i < doc.pages().count(); i++) {
		var page = doc.pages().objectAtIndex(i),
		layers = page.children();

		if (page.name != inventory.config.name) {
	    	// Loop through all children of the page

	    	for (var j = 0; j < layers.count(); j++) {

	    		// get the current layer

	    		var layer = layers.objectAtIndex(j);

	    		// Check if the layer is a text layer

	    		if([layer isKindOfClass:MSTextLayer]) {

	    			var textStyle = layer.style().textStyle().attributes();
	    			if (!isIncluded(uniqueTextStyles, textStyle)) {
	    				uniqueTextStyles.push(textStyle);
	    			}
	    		}
	    	}
	    }
	}

	// sort by font size
	uniqueTextStyles.sort(compare);
	[doc showMessage: uniqueTextStyles.length + " unique text styles found. " + definedTextStyles.length + " defined layer text styles found."]
}

function compare(a,b) {
	if (a.NSFont.fontDescriptor().objectForKey(NSFontSizeAttribute) < b.NSFont.fontDescriptor().objectForKey(NSFontSizeAttribute))
		return -1;
	if (a.NSFont.fontDescriptor().objectForKey(NSFontSizeAttribute) > b.NSFont.fontDescriptor().objectForKey(NSFontSizeAttribute))
		return 1;
	return 0;
}

function addCheckeredBackground(artboard) {
	var layer = artboard.addLayerOfType("rectangle");
	layer.frame().setWidth(artboard.frame().width())
	layer.frame().setHeight(artboard.frame().height())
	layer.style().fills().addNewStylePart();
	layer.style().fill().setFillType(4);
	layer.setName("Background");

	var scriptPath = sketch.scriptPath;
	var pluginFolder = scriptPath.match(/Plugins\/([\w -])*/)[0] + "/";
	var sketchPluginsPath = scriptPath.replace(/Plugins([\w \/ -])*.sketchplugin$/, "");
	imagesPath =  sketchPluginsPath;

	var fileName = imagesPath + inventory.config.background_image;

	var image = [[NSImage alloc] initWithContentsOfFile:fileName];

	layer.style().fill().setPatternImage(image)
}

function addPage(name) {
	// look for existing style sheet, otherwise create a new page with the styles
	var page = doc.addBlankPage();
	page.setName(name);
	[doc setCurrentPage:page]
	return page;
}

function isIncluded(arr, obj) {
  // indexOf compares searchElement to elements of the Array using strict equality
  // (the same method used by the ===, or triple-equals, operator).
  return (arr.indexOf(obj) != -1);
}

function removeAllLayersFromArtboard(artboard) {
	while(artboard.layers().count() > 0) {
		var layer = artboard.layers().objectAtIndex(0);
		artboard.removeLayer(layer);
	}
}

function layoutDefinedTextStyles(artboard) {

}

function createTextStyles (artboard) {
	var top = 0;
	var margin = 20;
	var maxWidth = 0;

	for (var i = 0; i < definedTextStyles.length; i++) {
		var textLayer = artboard.addLayerOfType("text");
		textLayer.setStringValue(inventory.config.textStylePlaceholder)
		// todo: use text style name as layer name
		textLayer.style().textStyle().setAttributes(definedTextStyles[i]);
		var theWidth = textLayer.frame().width();

		if (theWidth > maxWidth) maxWidth = theWidth;
		textLayer.frame().setX(margin);
		textLayer.frame().setY(top);

		top += textLayer.frame().height() + margin;
	}

	for (var i = 0; i < uniqueTextStyles.length; i++) {
		var textLayer = artboard.addLayerOfType("text");
		textLayer.setStringValue(inventory.config.textStylePlaceholder)
		textLayer.setName("Unique Text Style " + i)
		textLayer.style().textStyle().setAttributes(uniqueTextStyles[i]);
		var theWidth = textLayer.frame().width();

		if (theWidth > maxWidth) maxWidth = theWidth;
		textLayer.frame().setX(margin);
		textLayer.frame().setY(top);

		top += textLayer.frame().height() + margin;
	}

	[textLayer select:true byExpandingSelection:false]
	// centerView(textLayer)

	// Resize artboard and background to match the newly created text layers
	var background = artboard.layers().objectAtIndex(0);
	artboard.frame().setWidth(maxWidth + margin);
	background.frame().setWidth(maxWidth + margin);
	artboard.frame().setHeight(top + margin);
	background.frame().setHeight(top + margin);
	background.setIsLocked(true);
	zoomViewTo(artboard)

}

/*
 * createRuleSetStr by Tyler Gaw https://gist.github.com/tylergaw/adc3d6ad044f5afac446
 */

 function createRuleSetStr (layer) {
 	var str = '';
 	var selector = '.' + layer.name().toLowerCase().replace(/ /gi, '-');
 	var attrs = layer.CSSAttributes();

 	str += selector + ' {';

 	for (var i = 0; i < attrs.count(); i += 1) {
 		var declaration = attrs.objectAtIndex(i);

    // Sketch adds a comment to each rule set that is the name of the layer.
    // Don't include that.
    if (declaration.indexOf('/*') < 0) {
    	str += '\n\t' + declaration;
    }
}

str += '\n}';

return str;
}

function generateStyleSheet (layers) {
	var stylesheet = '';
	var stylesheet = "/* Text Styles from Sketch */";

	for (var i = 0; i < layers.count(); i += 1) {
		var layer = layers.objectAtIndex(i);

    	// only get CSS for text layers
    	if([layer isKindOfClass:MSTextLayer]) {
    		stylesheet += '\n\n' + createRuleSetStr(layer);
    	}
	}
	return stylesheet;
}

var clipboard = {
	// store the pasetboard object
	pasteBoard : null,

	// save the pasteboard object
	init : function()
	{
		this.pasteBoard = NSPasteboard.generalPasteboard();
	},
	// set the clipboard to the given text
	set : function( text )
	{
		if( typeof text === 'undefined' ) return null;

		if( !this.pasteBoard )
			this.init();

		this.pasteBoard.declareTypes_owner( [ NSPasteboardTypeString ], null );
		this.pasteBoard.setString_forType( text, NSPasteboardTypeString );

		return true;
	},
	// get text from the clipbaoard
	get : function()
	{
		if( !this.pasteBoard )
			this.init();

		var text = this.pasteBoard.stringForType( NSPasteboardTypeString );

		return text.toString();
	}
};

function save_file_from_string(filename,the_string) {
  var path = [@"" stringByAppendingString:filename],
      str = [@"" stringByAppendingString:the_string];

  if (in_sandbox()) {
    sandboxAccess.accessFilePath_withBlock_persistPermission(filename, function(){
      [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
    }, true)
  } else {
    [str writeToFile:path atomically:true encoding:NSUTF8StringEncoding error:null];
  }
}

function exportStyles() {
	var styleSheetString = generateStyleSheet(doc.currentPage().currentArtboard().children());

	var view = [doc currentView];
	view.refresh();

	// Document path
	var document_path = [[doc fileURL] path].split([doc displayName])[0];

	var path = document_path + "/typography.css"

	// Write file will crash sketch
	// todo: use sandbox.js to securely write file
	save_file_from_string(path, styleSheetString);
}

function centerView(layer) {
	var selected_object = layer,
    	view = [doc currentView]
	[view centerRect:[selected_object absoluteRect]]
}

function zoomViewTo(layer) {
	var view = [doc currentView]
	[view zoomToFitRect:[layer absoluteRect]]
}


analyseTextStyles();
analyseLayerTextStyles();
// analyseColors();

// for large files, sketch crashes after adding the style sheet page (a second time)
var styleSheetPage = inventory.common.getPageByName(inventory.config.name);
var artboard = inventory.common.getArtboardByPageAndName(styleSheetPage, "Typography");
removeAllLayersFromArtboard(artboard)
addCheckeredBackground(artboard);
createTextStyles(artboard);

// exportStyles();